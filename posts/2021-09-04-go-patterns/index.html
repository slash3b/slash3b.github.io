<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang channel tricks and patterns | Random notes to myself</title><meta name=keywords content><meta name=description content="Concurrency is the composition of independently executing computations.
Goroutines are not threads, but it is not wrong to think about goroutines as threads. In fact in runtime goroutines are multiplexed onto threads that are created as needed in order to make sure no goroutine ever blocks.
Generator Multiplexer nil channel trick Worker pool Generator. Function that returns never closed channel. Basically generate func returns unbuffered channel that is never closed and hence returns ever increasing counter."><meta name=author content><link rel=canonical href=https://slash3b.github.io/posts/2021-09-04-go-patterns/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://slash3b.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://slash3b.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://slash3b.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://slash3b.github.io/apple-touch-icon.png><link rel=mask-icon href=https://slash3b.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Golang channel tricks and patterns"><meta property="og:description" content="Concurrency is the composition of independently executing computations.
Goroutines are not threads, but it is not wrong to think about goroutines as threads. In fact in runtime goroutines are multiplexed onto threads that are created as needed in order to make sure no goroutine ever blocks.
Generator Multiplexer nil channel trick Worker pool Generator. Function that returns never closed channel. Basically generate func returns unbuffered channel that is never closed and hence returns ever increasing counter."><meta property="og:type" content="article"><meta property="og:url" content="https://slash3b.github.io/posts/2021-09-04-go-patterns/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-04T00:00:00+00:00"><meta property="article:modified_time" content="2021-09-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang channel tricks and patterns"><meta name=twitter:description content="Concurrency is the composition of independently executing computations.
Goroutines are not threads, but it is not wrong to think about goroutines as threads. In fact in runtime goroutines are multiplexed onto threads that are created as needed in order to make sure no goroutine ever blocks.
Generator Multiplexer nil channel trick Worker pool Generator. Function that returns never closed channel. Basically generate func returns unbuffered channel that is never closed and hence returns ever increasing counter."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://slash3b.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Golang channel tricks and patterns","item":"https://slash3b.github.io/posts/2021-09-04-go-patterns/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang channel tricks and patterns","name":"Golang channel tricks and patterns","description":"Concurrency is the composition of independently executing computations.\nGoroutines are not threads, but it is not wrong to think about goroutines as threads. In fact in runtime goroutines are multiplexed onto threads that are created as needed in order to make sure no goroutine ever blocks.\nGenerator Multiplexer nil channel trick Worker pool Generator. Function that returns never closed channel. Basically generate func returns unbuffered channel that is never closed and hence returns ever increasing counter.","keywords":[],"articleBody":"Concurrency is the composition of independently executing computations.\nGoroutines are not threads, but it is not wrong to think about goroutines as threads. In fact in runtime goroutines are multiplexed onto threads that are created as needed in order to make sure no goroutine ever blocks.\nGenerator Multiplexer nil channel trick Worker pool Generator. Function that returns never closed channel. Basically generate func returns unbuffered channel that is never closed and hence returns ever increasing counter.\npackage main import ( \"fmt\" \"strconv\" ) func main() { out := generate() for i := 0; i \u003c 5; i++ { fmt.Printf(\"Generated %s \\n\", \u003c-out) } fmt.Println(\"Done!\") } func generate() \u003c-chan string { a := make(chan string) go func() { i := 0 for { a \u003c- strconv.Itoa(i) i++ } }() return a } Multiplexer Otherwise knows as fan-in function Simple pattern in which two channels communicate with “fan in” channel concurrently.\npackage main import ( \"fmt\" \"math/rand\" \"time\" ) func sayHey(prefix string) \u003c-chan string { heyCh := make(chan string) go func() { for { // so it takes some time to output \"hey\" time.Sleep(time.Second * time.Duration(rand.Intn(4))) heyCh \u003c- fmt.Sprintf(\"hey %s\", prefix) } }() return heyCh } func fanIn(a, b \u003c-chan string) \u003c-chan string { fanInChannel := make(chan string) go func() { for { select { case fanInChannel \u003c- \u003c-a: case fanInChannel \u003c- \u003c-b: } } }() return fanInChannel } func main() { rand.Seed(time.Now().UnixNano()) a := sayHey(\"A\") b := sayHey(\"B\") fan := fanIn(a, b) for i := 0; i \u003c 6; i++ { fmt.Println(i, \u003c-fan) } fmt.Println(\"done!\") } NOTE. In these examples individual components we use are a sequential code and we are composing their independent execution.\nChannels are a first-class values in go. It means we can pass a channel to a channel, or e.g. a function to a function.\nnil channel trick way to disable a case in select package main import ( \"fmt\" \"math/rand\" \"time\" ) func main() { rand.Seed(time.Now().UnixNano()) a, b := make(chan string), make(chan string) go func() { a \u003c- \"A\" }() go func() { b \u003c- \"B\" }() // here, we randomly \"nullifying\" one of the channels, // effectively disabling `case` in `select` if 0 == rand.Intn(2) { a = nil } else { b = nil } select { case out := \u003c-a: fmt.Println(out) case out := \u003c-b: fmt.Println(out) } } Worker pool a pool of workers eager to process your data A pool of worker goroutines ready to process incoming channel. Example below uses unbuffered channel but it can use buffered as well if you need it.\npackage main import ( \"fmt\" ) func main() { in := make(chan int) out := make(chan int) for i := 0; i \u003c 5; i++ { go worker(i, in, out) } go func() { defer close(in) for i := 0; i \u003c 5; i++ { in \u003c- i } }() for i := 0; i \u003c 5; i++ { fmt.Printf(\"--\u003e reseived result %d from `out` channel \\n\", \u003c-out) } fmt.Println(\"END\") } func worker(id int, in \u003c-chan int, out chan\u003c- int) { for v := range in { result := v * 2 out \u003c- v fmt.Printf(\" \u003c-- worker #%d have sent value: %d \\n\", id, result) } fmt.Println(\"exiting worker #\", id) } Rate limiter simple rate limiter using a buffered channel wrap handler with a func that tries to add to channel and defers release. If lenght of buffered channel is 10 then when we have 10 ongoing requests will be pending\nrateLimiterMiddleware := func(f func(http.ResponseWriter, *http.Request)) func(http.ResponseWriter, *http.Request) { limitingBuffer := make(chan struct{}, 10) return func(w http.ResponseWriter, r *http.Request) { limitingBuffer \u003c- struct{}{} defer func() { \u003c-limitingBuffer }() f(w, r) } } Sources:\nhttps://www.youtube.com/watch?v=f6kdp27TYZs https://www.youtube.com/watch?v=QDDwwePbDtw ","wordCount":"608","inLanguage":"en","datePublished":"2021-09-04T00:00:00Z","dateModified":"2021-09-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://slash3b.github.io/posts/2021-09-04-go-patterns/"},"publisher":{"@type":"Organization","name":"Random notes to myself","logo":{"@type":"ImageObject","url":"https://slash3b.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://slash3b.github.io accesskey=h title="Random notes to myself (Alt + H)">Random notes to myself</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Golang channel tricks and patterns</h1><div class=post-meta><span title='2021-09-04 00:00:00 +0000 UTC'>September 4, 2021</span></div></header><div class=post-content><p>Concurrency is the composition of independently executing computations.</p><p>Goroutines are not threads, but it is not wrong to think about goroutines as threads.
In fact in runtime goroutines are multiplexed onto threads that are created as needed in order to make sure
no goroutine ever blocks.</p><ul><li><a href=#generator>Generator</a></li><li><a href=#multiplexer>Multiplexer</a></li><li><a href=#nil-channel-trick>nil channel trick</a></li><li><a href=#worker-pool>Worker pool</a></li></ul><h3 id=a-namegenerator-generator-function-that-returns-never-closed-channel-a>Generator. Function that returns never closed channel. <a hidden class=anchor aria-hidden=true href=#a-namegenerator-generator-function-that-returns-never-closed-channel-a>#</a></h3><p>Basically <code>generate</code> func returns unbuffered channel that is never closed and hence returns ever increasing counter.</p><pre tabindex=0><code>package main

import (
	&#34;fmt&#34;
	&#34;strconv&#34;
)

func main() {
	out := generate()

	for i := 0; i &lt; 5; i++ {
		fmt.Printf(&#34;Generated %s \n&#34;, &lt;-out)
	}

	fmt.Println(&#34;Done!&#34;)
}

func generate() &lt;-chan string {
	a := make(chan string)

	go func() {
		i := 0
		for {
			a &lt;- strconv.Itoa(i)
			i++
		}
	}()

	return a
}
</code></pre><h3 id=multiplexer>Multiplexer<a hidden class=anchor aria-hidden=true href=#multiplexer>#</a></h3><h4 id=otherwise-knows-as-fan-in-function>Otherwise knows as fan-in function<a hidden class=anchor aria-hidden=true href=#otherwise-knows-as-fan-in-function>#</a></h4><p>Simple pattern in which two channels communicate with &ldquo;fan in&rdquo; channel concurrently.</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;math/rand&#34;
    &#34;time&#34;
)

func sayHey(prefix string) &lt;-chan string {
    heyCh := make(chan string)

    go func() {
        for {
            // so it takes some time to output &#34;hey&#34;
            time.Sleep(time.Second * time.Duration(rand.Intn(4)))
            heyCh &lt;- fmt.Sprintf(&#34;hey %s&#34;, prefix)
        }
    }()

    return heyCh
}

func fanIn(a, b &lt;-chan string) &lt;-chan string {
    fanInChannel := make(chan string)

    go func() {

        for {
            select {
            case fanInChannel &lt;- &lt;-a:
            case fanInChannel &lt;- &lt;-b:
            }
        }
    }()

    return fanInChannel
}

func main() {
    rand.Seed(time.Now().UnixNano())

    a := sayHey(&#34;A&#34;)
    b := sayHey(&#34;B&#34;)

    fan := fanIn(a, b)

    for i := 0; i &lt; 6; i++ {
        fmt.Println(i, &lt;-fan)
    }

    fmt.Println(&#34;done!&#34;)
}
</code></pre><h4 id=note>NOTE.<a hidden class=anchor aria-hidden=true href=#note>#</a></h4><blockquote><p>In these examples individual components we use are a sequential code and we are composing
their independent execution.</p><p>Channels are a first-class values in go. It means we can pass a channel to a channel, or e.g. a function to a function.</p></blockquote><h3 id=nil-channel-trick>nil channel trick<a hidden class=anchor aria-hidden=true href=#nil-channel-trick>#</a></h3><h4 id=way-to-disable-a-case-in-select>way to disable a <code>case</code> in <code>select</code><a hidden class=anchor aria-hidden=true href=#way-to-disable-a-case-in-select>#</a></h4><pre tabindex=0><code>
package main

import (
    &#34;fmt&#34;
    &#34;math/rand&#34;
    &#34;time&#34;
)

func main() {

    rand.Seed(time.Now().UnixNano())
    a, b := make(chan string), make(chan string)
    go func() { a &lt;- &#34;A&#34; }()
    go func() { b &lt;- &#34;B&#34; }()

    // here, we randomly &#34;nullifying&#34; one of the channels,
    // effectively disabling `case` in `select`
    if 0 == rand.Intn(2) {
        a = nil
    } else {
        b = nil
    }

    select {
    case out := &lt;-a:
        fmt.Println(out)
    case out := &lt;-b:
        fmt.Println(out)
    }

}
</code></pre><h3 id=worker-pool>Worker pool<a hidden class=anchor aria-hidden=true href=#worker-pool>#</a></h3><h4 id=a-pool-of-workers-eager-to-process-your-data>a pool of workers eager to process your data<a hidden class=anchor aria-hidden=true href=#a-pool-of-workers-eager-to-process-your-data>#</a></h4><p>A pool of worker goroutines ready to process incoming channel.
Example below uses unbuffered channel but it can use buffered as well if you need it.</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
)

func main() {
    in := make(chan int)
    out := make(chan int)

    for i := 0; i &lt; 5; i++ {
        go worker(i, in, out)
    }

    go func() {
        defer close(in)
        for i := 0; i &lt; 5; i++ {
            in &lt;- i
        }
    }()

    for i := 0; i &lt; 5; i++ {
        fmt.Printf(&#34;--&gt; reseived result %d from `out` channel \n&#34;, &lt;-out)
    }

    fmt.Println(&#34;END&#34;)

}

func worker(id int, in &lt;-chan int, out chan&lt;- int) {
    for v := range in {
        result := v * 2
        out &lt;- v
        fmt.Printf(&#34; &lt;-- worker #%d have sent value: %d \n&#34;, id, result)
    }

    fmt.Println(&#34;exiting worker #&#34;, id)
}
</code></pre><h3 id=rate-limiter>Rate limiter<a hidden class=anchor aria-hidden=true href=#rate-limiter>#</a></h3><p>simple rate limiter using a buffered channel
wrap handler with a func that tries to add to channel
and defers release. If lenght of buffered channel is 10
then when we have 10 ongoing requests will be pending</p><pre tabindex=0><code>	rateLimiterMiddleware := func(f func(http.ResponseWriter, *http.Request)) func(http.ResponseWriter, *http.Request) {

		limitingBuffer := make(chan struct{}, 10)
		return func(w http.ResponseWriter, r *http.Request) {

			limitingBuffer &lt;- struct{}{}
			defer func() { &lt;-limitingBuffer }()

			f(w, r)
		}
	}
</code></pre><p>Sources:</p><ul><li><a href="https://www.youtube.com/watch?v=f6kdp27TYZs">https://www.youtube.com/watch?v=f6kdp27TYZs</a></li><li><a href="https://www.youtube.com/watch?v=QDDwwePbDtw">https://www.youtube.com/watch?v=QDDwwePbDtw</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://slash3b.github.io>Random notes to myself</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>