<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>HTTP versions difference | Random notes to myself</title><meta name=keywords content><meta name=description content="Here is the differences between HTTP versions with comments in plain english.
HTTP 1.0 capabilities: Request may consist of multiple newline separated header fields.
Response object is prefixed with a response status line.
Response object has its own set of newline separated header fields.
Response object is not limited to hypertext.
So basically since this version it is not hypertext but hypermedia protocol.
The connection between server and client is closed after every request."><meta name=author content><link rel=canonical href=https://slash3b.github.io/posts/2019-03-15-http-versions-difference/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://slash3b.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://slash3b.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://slash3b.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://slash3b.github.io/apple-touch-icon.png><link rel=mask-icon href=https://slash3b.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="HTTP versions difference"><meta property="og:description" content="Here is the differences between HTTP versions with comments in plain english.
HTTP 1.0 capabilities: Request may consist of multiple newline separated header fields.
Response object is prefixed with a response status line.
Response object has its own set of newline separated header fields.
Response object is not limited to hypertext.
So basically since this version it is not hypertext but hypermedia protocol.
The connection between server and client is closed after every request."><meta property="og:type" content="article"><meta property="og:url" content="https://slash3b.github.io/posts/2019-03-15-http-versions-difference/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-03-15T00:00:00+00:00"><meta property="article:modified_time" content="2019-03-15T00:00:00+00:00"><meta property="og:site_name" content="Random notes to myself"><meta name=twitter:card content="summary"><meta name=twitter:title content="HTTP versions difference"><meta name=twitter:description content="Here is the differences between HTTP versions with comments in plain english.
HTTP 1.0 capabilities: Request may consist of multiple newline separated header fields.
Response object is prefixed with a response status line.
Response object has its own set of newline separated header fields.
Response object is not limited to hypertext.
So basically since this version it is not hypertext but hypermedia protocol.
The connection between server and client is closed after every request."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://slash3b.github.io/posts/"},{"@type":"ListItem","position":3,"name":"HTTP versions difference","item":"https://slash3b.github.io/posts/2019-03-15-http-versions-difference/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"HTTP versions difference","name":"HTTP versions difference","description":"Here is the differences between HTTP versions with comments in plain english.\nHTTP 1.0 capabilities: Request may consist of multiple newline separated header fields.\nResponse object is prefixed with a response status line.\nResponse object has its own set of newline separated header fields.\nResponse object is not limited to hypertext.\nSo basically since this version it is not hypertext but hypermedia protocol.\nThe connection between server and client is closed after every request.","keywords":[],"articleBody":"Here is the differences between HTTP versions with comments in plain english.\nHTTP 1.0 capabilities: Request may consist of multiple newline separated header fields.\nResponse object is prefixed with a response status line.\nResponse object has its own set of newline separated header fields.\nResponse object is not limited to hypertext.\nSo basically since this version it is not hypertext but hypermedia protocol.\nThe connection between server and client is closed after every request.\nOne of the main drawbacks of this protocol version.\nSince that version, HTTP started to support caching, multipart messages, content encoding, authorization and much more.\nRead more in RFC 1945\nHTTP 1.1 features: Persistent connections to allow connection reuse. This one significantly increases performance, three way handshake and slow start are happening only in the beginning, not on every request like it used to be with 1.0 version. Persistent connection even when it is not being used is sutained by client via sending empty packets.\nChunked transfer encoding to allow response streaming. What is awesome about it is that you do not have to wait until your content is being generated, you can send it right away in chunks. Imagine to able to send your users a lengthy video file rigth away while this file is being generated at the same ime. The end of stream is done by special termination chunk which has length equal to 0.\nRequest pipelining to allow parallel request processing. I struggled to understand what is piplining is but after I read this zine by amazing Irina I think I have an explanation. Imagine transporter line for the baggage in the airport, each baggage is your request that uses the same connection(transporter line). You send it all at once and expect from the other side in the same sequence. HOL problem can be easily pictured here — one of the packages is stuck then the whole line is blocked! Check additional info here.\nRead more in RFC 2616\nHTTP 2 features: HTTP 2 was born out of SPDY protocol developed in Google. All the speed that comes with HTTP2 comes from binary framing layer, in other words in HTTP 1.x all comuunication is done in plaintext but in HTTP 2 it is done in binary.\nData compression of HTTP headers. This is truly awesome feature! Imagine you send multiple requests with almost the same headers, the difference could be only in that you ask each time different resource. So HTTP 2 use only that difference in headers and do not sent the same headers on and on again. This is called “compression of HTTP headers”.\nHTTP/2 Server Push\nPipelining of requests\nFixing the head-of-line blocking problem in HTTP 1.x\nMultiplexing multiple requests over a single TCP connection\nOne of the coolest features, improves speed significantly, decreases number of connections.\nRead more in RFC 2068\nHTTP 3 features: One of the problems of HTTP2 is that it is still using TCP protocol, so in case a single packet is dropped/lost the entire connection stops and waits for this packet. This is called ‘TCP head of line blocking’\nStream multiplexing\nPer-stream flow control\nLow latency connection establishement\nSecure by default with TLS 1.3\nMuch faster handshake\nFix for TCP head of line blocking\nResources used:\nHigh Performance Browser Networking\nQUICK internet draft\nHTTP3 explained HTTP encoding/compression HTTP3. It is all about the transport!\n","wordCount":"560","inLanguage":"en","datePublished":"2019-03-15T00:00:00Z","dateModified":"2019-03-15T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://slash3b.github.io/posts/2019-03-15-http-versions-difference/"},"publisher":{"@type":"Organization","name":"Random notes to myself","logo":{"@type":"ImageObject","url":"https://slash3b.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://slash3b.github.io accesskey=h title="Home (Alt + H)"><img src=https://slash3b.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://slash3b.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://slash3b.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>HTTP versions difference</h1><div class=post-meta><span title='2019-03-15 00:00:00 +0000 UTC'>March 15, 2019</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;560 words&nbsp;|&nbsp;<a href=https://github.com/slash3b/slash3b.github.io/content/posts/2019-03-15-http-versions-difference.markdown rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Here is the differences between HTTP versions with comments in plain english.</p><h2 id=http-10-capabilities>HTTP 1.0 capabilities:<a hidden class=anchor aria-hidden=true href=#http-10-capabilities>#</a></h2><ul><li><p>Request may consist of multiple newline separated header fields.</p></li><li><p>Response object is prefixed with a response status line.</p></li><li><p>Response object has its own set of newline separated header fields.</p></li><li><p>Response object is not limited to hypertext.<br>So basically since this version it is not hypertext but hypermedia protocol.</p></li><li><p>The connection between server and client is closed after every request.<br>One of the main drawbacks of this protocol version.</p></li></ul><p>Since that version, HTTP started to support caching, multipart messages, content encoding, authorization and much more.</p><p>Read more in <a href=https://tools.ietf.org/html/rfc1945>RFC 1945</a></p><h2 id=http-11-features>HTTP 1.1 features:<a hidden class=anchor aria-hidden=true href=#http-11-features>#</a></h2><ul><li><p>Persistent connections to allow connection reuse. This one significantly increases performance, three way handshake and slow start are happening only in the beginning, not on every request like it used to be with 1.0 version. Persistent connection even when it is not being used is sutained by client via sending empty packets.</p></li><li><p>Chunked transfer encoding to allow response streaming. What is awesome about it is that you do not have to wait until your content is being generated, you can send it right away in chunks. Imagine to able to send your users a lengthy video file rigth away while this file is being generated at the same ime. The end of stream is done by special termination chunk which has length equal to 0.</p></li><li><p>Request pipelining to allow parallel request processing. I struggled to understand what is piplining is but after I read this <a href=https://github.com/lrlna/sketchin/blob/master/zines/http2.md>zine</a> by amazing Irina I think I have an explanation. Imagine transporter line for the baggage in the airport, each baggage is your request that uses the same connection(transporter line). You send it all at once and expect from the other side in the same sequence. HOL problem can be easily pictured here — one of the packages is stuck then the whole line is blocked!<br>Check additional info <a href=https://hpbn.co/http1x/>here</a>.</p></li></ul><p>Read more in <a href=https://www.ietf.org/rfc/rfc2616.txt>RFC 2616</a></p><h2 id=http-2-features>HTTP 2 features:<a hidden class=anchor aria-hidden=true href=#http-2-features>#</a></h2><p>HTTP 2 was born out of SPDY protocol developed in Google. All the speed that comes with HTTP2 comes from <em>binary framing layer</em>, in other words in HTTP 1.x all comuunication is done in plaintext but in HTTP 2 it is done in binary.</p><ul><li><p>Data compression of HTTP headers. This is truly awesome feature! Imagine you send multiple requests with almost the same headers, the difference could be only in that you ask each time different resource. So HTTP 2 use only that difference in headers and do not sent the same headers on and on again. This is called &ldquo;compression of HTTP headers&rdquo;.</p></li><li><p>HTTP/2 Server Push</p></li><li><p>Pipelining of requests</p></li><li><p>Fixing the head-of-line blocking problem in HTTP 1.x</p></li><li><p>Multiplexing multiple requests over a single TCP connection<br>One of the coolest features, improves speed significantly, decreases number of connections.</p></li></ul><p>Read more in <a href=https://tools.ietf.org/html/rfc2068>RFC 2068</a></p><h2 id=http-3-features>HTTP 3 features:<a hidden class=anchor aria-hidden=true href=#http-3-features>#</a></h2><p>One of the problems of HTTP2 is that it is still using TCP protocol, so in case a single packet is dropped/lost the entire connection stops and waits for this packet. This is called &lsquo;TCP head of line blocking&rsquo;</p><ul><li><p>Stream multiplexing</p></li><li><p>Per-stream flow control</p></li><li><p>Low latency connection establishement</p></li><li><p>Secure by default with TLS 1.3</p></li><li><p>Much faster handshake</p></li><li><p>Fix for TCP head of line blocking</p></li></ul><p>Resources used:</p><p><a href=https://hpbn.co>High Performance Browser Networking</a><br><a href=https://quicwg.org/base-drafts/draft-ietf-quic-http.html>QUICK internet draft</a><br><a href=https://http3-explained.haxx.se/>HTTP3 explained</a>
<a href=https://en.wikipedia.org/wiki/HTTP_compression>HTTP encoding/compression</a>
<a href=https://speakerdeck.com/bitone/3>HTTP3. It is all about the transport!</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://slash3b.github.io/posts/2019-04-13-inheritance-and-composition-in-php/><span class=title>« Prev</span><br><span>Composition vs. Inheritance in PHP, tl;dr version</span></a>
<a class=next href=https://slash3b.github.io/posts/2019-02-17-visitor-design-pattern/><span class=title>Next »</span><br><span>Visitor Design Pattern</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://slash3b.github.io>Random notes to myself</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>