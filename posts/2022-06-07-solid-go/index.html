<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Go | Random notes to myself</title>
<meta name=keywords content="SOLID,golang"><meta name=description content="SOLID is a famous cargo-cult that is used to poke &ldquo;bad&rdquo; code during code review. Jokes aside there are some solid, pun
intended, ideas within SOLID. This post is yet another attempt to dismantle this set of principles and understand them
better.
The SOLID stands for(pasted from wiki):

S ingle-responsibility principle: &ldquo;There should never be more than one reason for a class to change.&ldquo;In other words, every class should have only one responsibility
O pen–closed principle: &ldquo;Software entities &mldr; should be open for extension, but closed for modification.&rdquo;
L iskov substitution principle: &ldquo;Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.&ldquo;See also design by contract.
I nterface segregation principle: &ldquo;Many client-specific interfaces are better than one general-purpose interface.&rdquo;
D ependency inversion principle: &ldquo;Depend upon abstractions, [not] concretions.&rdquo;

S
single responsibility
Out of all these, only first one makes sense right away. If you are not a complete beginner, you won&rsquo;t create a
struct that does shipping calculation, checks weather condition, sends push notification and orders pizza. Don&rsquo;t you?"><meta name=author content><link rel=canonical href=https://slash3b.github.io/posts/2022-06-07-solid-go/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://slash3b.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://slash3b.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://slash3b.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://slash3b.github.io/apple-touch-icon.png><link rel=mask-icon href=https://slash3b.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://slash3b.github.io/posts/2022-06-07-solid-go/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SOLID Go"><meta property="og:description" content="SOLID is a famous cargo-cult that is used to poke &ldquo;bad&rdquo; code during code review. Jokes aside there are some solid, pun
intended, ideas within SOLID. This post is yet another attempt to dismantle this set of principles and understand them
better.
The SOLID stands for(pasted from wiki):

S ingle-responsibility principle: &ldquo;There should never be more than one reason for a class to change.&ldquo;In other words, every class should have only one responsibility
O pen–closed principle: &ldquo;Software entities &mldr; should be open for extension, but closed for modification.&rdquo;
L iskov substitution principle: &ldquo;Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.&ldquo;See also design by contract.
I nterface segregation principle: &ldquo;Many client-specific interfaces are better than one general-purpose interface.&rdquo;
D ependency inversion principle: &ldquo;Depend upon abstractions, [not] concretions.&rdquo;

S
single responsibility
Out of all these, only first one makes sense right away. If you are not a complete beginner, you won&rsquo;t create a
struct that does shipping calculation, checks weather condition, sends push notification and orders pizza. Don&rsquo;t you?"><meta property="og:type" content="article"><meta property="og:url" content="https://slash3b.github.io/posts/2022-06-07-solid-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-06T17:29:38+02:00"><meta property="article:modified_time" content="2022-06-06T17:29:38+02:00"><meta property="og:site_name" content="Random notes to myself"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Go"><meta name=twitter:description content="SOLID is a famous cargo-cult that is used to poke &ldquo;bad&rdquo; code during code review. Jokes aside there are some solid, pun
intended, ideas within SOLID. This post is yet another attempt to dismantle this set of principles and understand them
better.
The SOLID stands for(pasted from wiki):

S ingle-responsibility principle: &ldquo;There should never be more than one reason for a class to change.&ldquo;In other words, every class should have only one responsibility
O pen–closed principle: &ldquo;Software entities &mldr; should be open for extension, but closed for modification.&rdquo;
L iskov substitution principle: &ldquo;Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.&ldquo;See also design by contract.
I nterface segregation principle: &ldquo;Many client-specific interfaces are better than one general-purpose interface.&rdquo;
D ependency inversion principle: &ldquo;Depend upon abstractions, [not] concretions.&rdquo;

S
single responsibility
Out of all these, only first one makes sense right away. If you are not a complete beginner, you won&rsquo;t create a
struct that does shipping calculation, checks weather condition, sends push notification and orders pizza. Don&rsquo;t you?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://slash3b.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SOLID Go","item":"https://slash3b.github.io/posts/2022-06-07-solid-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Go","name":"SOLID Go","description":"SOLID is a famous cargo-cult that is used to poke \u0026ldquo;bad\u0026rdquo; code during code review. Jokes aside there are some solid, pun intended, ideas within SOLID. This post is yet another attempt to dismantle this set of principles and understand them better.\nThe SOLID stands for(pasted from wiki):\nS ingle-responsibility principle: \u0026ldquo;There should never be more than one reason for a class to change.\u0026ldquo;In other words, every class should have only one responsibility O pen–closed principle: \u0026ldquo;Software entities \u0026hellip; should be open for extension, but closed for modification.\u0026rdquo; L iskov substitution principle: \u0026ldquo;Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\u0026ldquo;See also design by contract. I nterface segregation principle: \u0026ldquo;Many client-specific interfaces are better than one general-purpose interface.\u0026rdquo; D ependency inversion principle: \u0026ldquo;Depend upon abstractions, [not] concretions.\u0026rdquo; S single responsibility Out of all these, only first one makes sense right away. If you are not a complete beginner, you won\u0026rsquo;t create a struct that does shipping calculation, checks weather condition, sends push notification and orders pizza. Don\u0026rsquo;t you?\n","keywords":["SOLID","golang"],"articleBody":"SOLID is a famous cargo-cult that is used to poke “bad” code during code review. Jokes aside there are some solid, pun intended, ideas within SOLID. This post is yet another attempt to dismantle this set of principles and understand them better.\nThe SOLID stands for(pasted from wiki):\nS ingle-responsibility principle: “There should never be more than one reason for a class to change.“In other words, every class should have only one responsibility O pen–closed principle: “Software entities … should be open for extension, but closed for modification.” L iskov substitution principle: “Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.“See also design by contract. I nterface segregation principle: “Many client-specific interfaces are better than one general-purpose interface.” D ependency inversion principle: “Depend upon abstractions, [not] concretions.” S single responsibility Out of all these, only first one makes sense right away. If you are not a complete beginner, you won’t create a struct that does shipping calculation, checks weather condition, sends push notification and orders pizza. Don’t you?\nSingle responsibility principle also relates to package naming and content. Packages with e.g. name “common” become a dump that does many things and exported everywhere.\nO open for extension, closed for modification package main type A struct { year int } func (a A) Greet() { fmt.Println(\"Hello GolangUK\", a.year) } type B struct { A } func (b B) Greet() { fmt.Println(\"Welcome to GolangUK\", b.year) } func main() { var a A a.year = 2016 var b B b.year = 2016 a.Greet() // Hello GolangUK 2016 b.Greet() // Welcome to GolangUK 2016 } In this example by Dave Cheney, although\nThanks to embedding B can use, but not change non-exported fields from A. Embedding in go naturally allows golang types to be open for extension by overriding or adding new methods. At the same time there is no way you can change Greet() in A struct from B struct. Well, you can change year, of course.\nL Liskov substitution principle “two types are substitutable if they behave in the way such that the caller is unable to tell difference between them”\nI interface segregation or do not depend on stuff you do not need In Layman terms do not force your code to depened on stuff it does not need or use. Which basically means — keep your interfaces small, it will help to have interface clients to not depend on stuff they do not need.\nI will just copy-paste here a brilliant example by Dave Cheney:\n1 func Save(f *os.File, d *Document) error │ ▼ 2 func Save(f io.ReadWriteCloser, d *Document) error │ ▼ 3 func Save(f io.WriteCloser, d *Document) error │ ▼ 4 func Save(f io.Writer, d *Document) error Simply put, on line 1 Save method can only save to file, which does not allow us to “save” to any other place. It also makes testing harder — you have to use a real file for testing. Evolution of Save method boils down to the simple signature and at the same the most benevolent one. Now anything that implements io.Writer can be used to Save document.\nD dependency inversion Depend on abstactions, not concretions. I think it means that everything you use in your structs should rely on interfaces and not concrete instances.\nSources:\nhttps://en.wikipedia.org/wiki/SOLID https://www.youtube.com/watch?v=zzAdEt3xZ1M ","wordCount":"558","inLanguage":"en","datePublished":"2022-06-06T17:29:38+02:00","dateModified":"2022-06-06T17:29:38+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://slash3b.github.io/posts/2022-06-07-solid-go/"},"publisher":{"@type":"Organization","name":"Random notes to myself","logo":{"@type":"ImageObject","url":"https://slash3b.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://slash3b.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://slash3b.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://slash3b.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://slash3b.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">SOLID Go</h1><div class=post-meta><span title='2022-06-06 17:29:38 +0200 +0200'>June 6, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;558 words&nbsp;|&nbsp;<a href=https://github.com/slash3b/slash3b.github.io/content/posts/2022-06-07-solid-go.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>SOLID is a famous cargo-cult that is used to poke &ldquo;bad&rdquo; code during code review. Jokes aside there are some solid, pun
intended, ideas within SOLID. This post is yet another attempt to dismantle this set of principles and understand them
better.</p><p>The SOLID stands for(pasted from wiki):</p><ul><li><strong>S</strong> ingle-responsibility principle: &ldquo;There should never be more than one reason for a class to change.&ldquo;In other words, every class should have only one responsibility</li><li><strong>O</strong> pen–closed principle: &ldquo;Software entities &mldr; should be open for extension, but closed for modification.&rdquo;</li><li><strong>L</strong> iskov substitution principle: &ldquo;Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.&ldquo;See also design by contract.</li><li><strong>I</strong> nterface segregation principle: &ldquo;Many client-specific interfaces are better than one general-purpose interface.&rdquo;</li><li><strong>D</strong> ependency inversion principle: &ldquo;Depend upon abstractions, [not] concretions.&rdquo;</li></ul><h3 id=s>S<a hidden class=anchor aria-hidden=true href=#s>#</a></h3><h5 id=single-responsibility>single responsibility<a hidden class=anchor aria-hidden=true href=#single-responsibility>#</a></h5><p>Out of all these, only first one makes sense right away. If you are not a complete beginner, you won&rsquo;t create a
struct that does shipping calculation, checks weather condition, sends push notification and orders pizza. Don&rsquo;t you?</p><p>Single responsibility principle also relates to package naming and content. Packages with e.g. name &ldquo;common&rdquo; become a dump
that does many things and exported everywhere.</p><h3 id=o>O<a hidden class=anchor aria-hidden=true href=#o>#</a></h3><h5 id=open-for-extension-closed-for-modification>open for extension, closed for modification<a hidden class=anchor aria-hidden=true href=#open-for-extension-closed-for-modification>#</a></h5><pre tabindex=0><code>package main

type A struct {
        year int
}

func (a A) Greet() { fmt.Println(&#34;Hello GolangUK&#34;, a.year) }

type B struct {
        A
}

func (b B) Greet() { fmt.Println(&#34;Welcome to GolangUK&#34;, b.year) }

func main() {
        var a A
        a.year = 2016
        var b B
        b.year = 2016
        a.Greet() // Hello GolangUK 2016
        b.Greet() // Welcome to GolangUK 2016
}
</code></pre><p>In this example by Dave Cheney, although</p><p>Thanks to embedding B can <strong>use, but not change</strong> non-exported fields from A.
Embedding in go naturally allows golang types to be open for extension by overriding or adding new methods. At the same
time there is no way you can change <code>Greet()</code> in A struct from B struct. Well, you can change <code>year</code>, of course.</p><h3 id=l>L<a hidden class=anchor aria-hidden=true href=#l>#</a></h3><h5 id=liskov-substitution-principle>Liskov substitution principle<a hidden class=anchor aria-hidden=true href=#liskov-substitution-principle>#</a></h5><p>&ldquo;two types are substitutable if they behave in the way such that the caller is unable to tell difference between them&rdquo;</p><h3 id=i>I<a hidden class=anchor aria-hidden=true href=#i>#</a></h3><h5 id=interface-segregation-or-do-not-depend-on-stuff-you-do-not-need>interface segregation or do not depend on stuff you do not need<a hidden class=anchor aria-hidden=true href=#interface-segregation-or-do-not-depend-on-stuff-you-do-not-need>#</a></h5><p>In Layman terms do not force your code to depened on stuff it does not need or use. Which basically means — keep your interfaces small, it will help to have interface clients to not depend on stuff they
do not need.</p><p>I will just copy-paste here a brilliant example by Dave Cheney:</p><pre tabindex=0><code>1 func Save(f *os.File, d *Document) error
                   │
                   ▼
2 func Save(f io.ReadWriteCloser, d *Document) error
                   │
                   ▼
3 func Save(f io.WriteCloser, d *Document) error
                   │
                   ▼
4 func Save(f io.Writer, d *Document) error 
</code></pre><p>Simply put, on line <code>1</code> <code>Save</code> method can only save to file, which does not allow us to &ldquo;save&rdquo; to any other place. It also
makes testing harder — you have to use a real file for testing. Evolution of <code>Save</code> method boils down to the simple
signature and at the same the most benevolent one. Now anything that implements <code>io.Writer</code> can be used to Save
document.</p><h3 id=d>D<a hidden class=anchor aria-hidden=true href=#d>#</a></h3><h5 id=dependency-inversion>dependency inversion<a hidden class=anchor aria-hidden=true href=#dependency-inversion>#</a></h5><p>Depend on abstactions, not concretions. I think it means that everything you use in your structs should rely on
interfaces and not concrete instances.</p><p>Sources:</p><ul><li><a href=https://en.wikipedia.org/wiki/SOLID>https://en.wikipedia.org/wiki/SOLID</a></li><li><a href="https://www.youtube.com/watch?v=zzAdEt3xZ1M">https://www.youtube.com/watch?v=zzAdEt3xZ1M</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://slash3b.github.io/tags/solid/>SOLID</a></li><li><a href=https://slash3b.github.io/tags/golang/>Golang</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://slash3b.github.io/>Random notes to myself</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>