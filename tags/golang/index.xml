<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Golang on Random notes to myself</title>
    <link>https://slash3b.github.io/tags/golang/</link>
    <description>Recent content in Golang on Random notes to myself</description>
    <generator>Hugo -- 0.125.6</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Jun 2022 17:29:38 +0200</lastBuildDate>
    <atom:link href="https://slash3b.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SOLID Go</title>
      <link>https://slash3b.github.io/posts/2022-06-07-solid-go/</link>
      <pubDate>Mon, 06 Jun 2022 17:29:38 +0200</pubDate>
      <guid>https://slash3b.github.io/posts/2022-06-07-solid-go/</guid>
      <description>SOLID is a famous cargo-cult that is used to poke &amp;ldquo;bad&amp;rdquo; code during code review. Jokes aside there are some solid, pun intended, ideas within SOLID. This post is yet another attempt to dismantle this set of principles and understand them better.
The SOLID stands for(pasted from wiki):
S ingle-responsibility principle: &amp;ldquo;There should never be more than one reason for a class to change.&amp;ldquo;In other words, every class should have only one responsibility O pen–closed principle: &amp;ldquo;Software entities &amp;hellip; should be open for extension, but closed for modification.</description>
    </item>
    <item>
      <title>Notes on Garbage Collection in Golang</title>
      <link>https://slash3b.github.io/posts/2022-06-05-notes-on-garbage-collection-in-go/</link>
      <pubDate>Sun, 05 Jun 2022 17:29:38 +0200</pubDate>
      <guid>https://slash3b.github.io/posts/2022-06-05-notes-on-garbage-collection-in-go/</guid>
      <description>Garbage Collection is a process of freeing memory that is allocated and contains some data that is not being used.
Notes:
by doing escape analysis GC mechanism decides what goes to heap and what stays on stack use -gcflags &#39;-m&#39; flag to get escape analysis info, e.g. go run -gcflags &#39;-m&#39; main.go another way to look into what GC is doing during runtime is to run program with GODEBUG=gctrace=1 GC runs consurrently with main program running main running program is called &amp;ldquo;mutator&amp;rdquo; Golang Garbage Collection uses &amp;ldquo;tricolor algorithm&amp;rdquo; otherwise known as tricolor mark and sweep algorithm.</description>
    </item>
    <item>
      <title>Simple case of profiler usage in golang</title>
      <link>https://slash3b.github.io/posts/2021-12-28-simple-case-of-golang-profiler-usage/</link>
      <pubDate>Tue, 28 Dec 2021 17:29:38 +0200</pubDate>
      <guid>https://slash3b.github.io/posts/2021-12-28-simple-case-of-golang-profiler-usage/</guid>
      <description>So I was solving Construct Binary Tree from Inorder and Postorder Traversal and I got myself more less working solution that got accepted.
But it was not the fastest one.
But then I though — how do I profile buildTree function and see what actually takes time in my program?
Golang has an excellent set of tool available, just check an output of go tool. One of the items in a list you&amp;rsquo;ll see is pprof which is a Golang profiler.</description>
    </item>
  </channel>
</rss>
