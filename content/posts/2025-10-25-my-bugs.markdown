---
layout: post
date:   2025-10-25
comments: false
title: My Bugs Graveyard
---

#### 1. HTTP call to 3rd party API responds with error from our local database

Diagnosis: I see a weird error in the logs, it looks like something like this:
```
error happened GET https://example.com, <service database error>

```
where you can see endpoint url and denoted with angle brackets an error from our own database. What the heck? How come we get an error from our own database when we call an endpoint?!

Below you will find a completely reproducible example:

```golang
package main

import (
	"context"
	"fmt"
	"net/http"
	"net/http/httptest"
	"time"

	"golang.org/x/sync/errgroup"
)

func main() {
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(2 * time.Second)
		w.WriteHeader(http.StatusOK)
	}))
	defer server.Close()

	g, ctx := errgroup.WithContext(context.Background())

	g.Go(func() error {
		time.Sleep(500 * time.Millisecond)
		return fmt.Errorf("mongodb_error_poison")
	})

	g.Go(func() error {
		req, _ := http.NewRequestWithContext(ctx, http.MethodGet, server.URL, nil)
		_, err := http.DefaultClient.Do(req)
		if err != nil {
			fmt.Printf("client.Do error: %v\n", err)
		}
		return err
	})

	g.Wait()
}

```

and the output will be:
```
client.Do error: Get "http://127.0.0.1:41339": mongodb_error_poison
```

how come? what is going on? any guesses?
turns out the following is happening:
errgroup.Wait will cancel the context as soon as any of gorouitines return an error.
internally errgroup will use a special `context.WithCancelCause` context which returns context itself
and cancel that **accepts an error** as a cause.  

now as soon as context is cancelled `http.DefaultClient.Do(req)` with request that has our context immediately return error.
but method `Do` has this comment:
`// Any returned error will be of type [*url.Error].`
and the `url.Error` looks like this 
```
// Error reports an error and the operation and URL that caused it.
type Error struct {
        Op  string
        URL string
        Err error
}
```
long story short that cause from context, which is an error,  will be assigned to `Err` field in `url.Error`
and this is how database error bubbled up was returned from http call.


```golang

package main

import (
	"context"
	"fmt"
	"net/http"
	"net/http/httptest"
	"time"

	"golang.org/x/sync/errgroup"
)

func main() {
	// 1. Setup a slow server that sleeps longer than the "poison" delay
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		//fmt.Println("[Server] Received request, sleeping...")
		time.Sleep(2 * time.Second) // Sleep longer than the error trigger
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("OK"))
		// fmt.Println("[Server] Request completed (should not be seen if context cancels client)")
	}))
	defer server.Close()

	ctx := context.Background()
	g, ctx := errgroup.WithContext(ctx)

	// 2. Routine 1: The "Poison" - fails quickly
	g.Go(func() error {
		fmt.Println("[Poison] Waiting to trigger error...")
		time.Sleep(500 * time.Millisecond)
		fmt.Println("[Poison] TRIGGERING ERROR: an error poisoned the workflow!")
		return fmt.Errorf("mongodb_error_poison")
	})

	// 3. Routine 2: The "Victim" - tries to fetch data with retries
	g.Go(func() error {
		return fetchDataBuggy(ctx, server.URL)
	})

	// Wait for completion
	if err := g.Wait(); err != nil {
		fmt.Printf("\n[Main] Workflow finished with error: %v\n", err)
	} else {
		fmt.Println("\n[Main] Workflow finished successfully")
	}
}

// fetchDataBuggy reproduces the issue where we retry on context cancellation
// because we don't check ctx.Err() explicitly when client.Do returns an error.
func fetchDataBuggy(ctx context.Context, url string) error {
	client := &http.Client{
		Timeout: 10 * time.Second, // Long enough timeout
	}

	maxRetries := 5

	for i := 0; i < maxRetries; i++ {
		fmt.Printf("[Client] Attempt %d starting...\n", i+1)

		req, _ := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
		
		// When the context is cancelled by the [Poison] routine, 
		// client.Do returns an error.
		_, err := client.Do(req)
		
		if err != nil {
			// --- THE BUG IS HERE ---
			// We treat this error as a network glitch and retry.
			// But the error is actually due to context cancellation!
			
			fmt.Printf("[Client] Attempt %d failed. Error type: %T. Error: %v\n", i+1, err, err)
			
			// To prove the point, let's check if context is actually cancelled
			if ctx.Err() != nil {
				fmt.Printf("[Client] (Debug) Context IS cancelled: %v. But we are retrying anyway!\n", ctx.Err())
			}

			// Simple backoff
			retryWait := 500 * time.Millisecond
			fmt.Printf("[Client] Sleeping %v before retry...\n\n", retryWait)
			
			// We sleep. If context is cancelled, time.Sleep returns immediately? 
			// No, time.Sleep takes a Duration, it doesn't know about context.
			// So we actually pause execution here.
			time.Sleep(retryWait)
			
			continue
		}
		
		fmt.Println("[Client] Success!")
		return nil
	}

	return fmt.Errorf("max retries exceeded")
}

```

An output will look like so:

```
slash3b@Xtal /t/tmp.NRGeUVBS7A> go run main.go
[Client] Attempt 1 starting...
[Poison] Waiting to trigger error...
[Poison] TRIGGERING ERROR: an error poisoned the workflow!
[Client] Attempt 1 failed. Error type: *url.Error. Error: Get "http://127.0.0.1:45689": mongodb_error_poison
[Client] (Debug) Context IS cancelled: context canceled. But we are retrying anyway!
[Client] Sleeping 500ms before retry...

[Client] Attempt 2 starting...
[Client] Attempt 2 failed. Error type: *url.Error. Error: Get "http://127.0.0.1:45689": mongodb_error_poison
[Client] (Debug) Context IS cancelled: context canceled. But we are retrying anyway!
[Client] Sleeping 500ms before retry...

[Client] Attempt 3 starting...
[Client] Attempt 3 failed. Error type: *url.Error. Error: Get "http://127.0.0.1:45689": mongodb_error_poison
[Client] (Debug) Context IS cancelled: context canceled. But we are retrying anyway!
[Client] Sleeping 500ms before retry...

[Client] Attempt 4 starting...
[Client] Attempt 4 failed. Error type: *url.Error. Error: Get "http://127.0.0.1:45689": mongodb_error_poison
[Client] (Debug) Context IS cancelled: context canceled. But we are retrying anyway!
[Client] Sleeping 500ms before retry...

[Client] Attempt 5 starting...
[Client] Attempt 5 failed. Error type: *url.Error. Error: Get "http://127.0.0.1:45689": mongodb_error_poison
[Client] (Debug) Context IS cancelled: context canceled. But we are retrying anyway!
[Client] Sleeping 500ms before retry...


[Main] Workflow finished with error: mongodb_error_poison
```
