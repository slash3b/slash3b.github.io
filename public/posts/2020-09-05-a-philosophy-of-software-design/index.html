<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A philosophy of software design by John Ousterhout | Random notes to myself</title><meta name=keywords content><meta name=description content="I like that book and decided to make a &ldquo;short&rdquo; version for myself to remember it better.
The book is only 190 pages long but it has lots of valuable advices and author takes things straight to the point.
This is just my own &ldquo;retelling&rdquo; of the book. If you are reading this I encourage you to first buy and read the whole book and only then this text below might make sense to you."><meta name=author content><link rel=canonical href=https://slash3b.github.io/posts/2020-09-05-a-philosophy-of-software-design/><link crossorigin=anonymous href=/assets/css/stylesheet.min.61dfb3f0b4cda95d2ccb867f9a3b244ce5d23e12492bcc3c277df594c7bc1adf.css integrity="sha256-Yd+z8LTNqV0sy4Z/mjskTOXSPhJJK8w8J331lMe8Gt8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://slash3b.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://slash3b.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://slash3b.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://slash3b.github.io/apple-touch-icon.png><link rel=mask-icon href=https://slash3b.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.68.3"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="A philosophy of software design by John Ousterhout"><meta property="og:description" content="I like that book and decided to make a &ldquo;short&rdquo; version for myself to remember it better.
The book is only 190 pages long but it has lots of valuable advices and author takes things straight to the point.
This is just my own &ldquo;retelling&rdquo; of the book. If you are reading this I encourage you to first buy and read the whole book and only then this text below might make sense to you."><meta property="og:type" content="article"><meta property="og:url" content="https://slash3b.github.io/posts/2020-09-05-a-philosophy-of-software-design/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-05T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A philosophy of software design by John Ousterhout"><meta name=twitter:description content="I like that book and decided to make a &ldquo;short&rdquo; version for myself to remember it better.
The book is only 190 pages long but it has lots of valuable advices and author takes things straight to the point.
This is just my own &ldquo;retelling&rdquo; of the book. If you are reading this I encourage you to first buy and read the whole book and only then this text below might make sense to you."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"A philosophy of software design by John Ousterhout","item":"https://slash3b.github.io/posts/2020-09-05-a-philosophy-of-software-design/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A philosophy of software design by John Ousterhout","name":"A philosophy of software design by John Ousterhout","description":"I like that book and decided to make a \u0026ldquo;short\u0026rdquo; version for myself to remember it better.\nThe book is only 190 pages long but it has lots of valuable advices and author takes things straight to the point.\nThis is just my own \u0026ldquo;retelling\u0026rdquo; of the book. If you are reading this I encourage you to first buy and read the whole book and only then this text below might make sense to you.","keywords":[],"articleBody":"I like that book and decided to make a “short” version for myself to remember it better.\nThe book is only 190 pages long but it has lots of valuable advices and author takes things straight to the point.\nThis is just my own “retelling” of the book. If you are reading this I encourage you to first buy and read the whole book and only then this text below might make sense to you. Or not.\nChapter 1. Introduction …All programming requires is a creative mind and the ability to organize your thoughts. If you can visualize a system, you can probably implement it in a computer program. Any system inevitably becomes complex over time — as it grows and more and more people work on it. Complexity growth makes it next to impossible to hold a clear and complete picture of a system in one’s head.\nBottom line is — complexity will grow anyway but it is your reponsibility and duty to hold that growth as much as you can.\nThere are two ways to fight complexity:\n make code more simple and obvious incapsulation of a complexity using modular design  Sofware design is never done, it happens through the lifetime of a software. You should always think about system desing and ways to improve it.\nChapter 2. The nature of complexity Complexity is anything related to the structure of a software system that makes it hard to understand, modify and maintain the system. Another view at complexity is a cost of development — it takes much time to implement event the simple features, usually you have to change lots of files to do it and overall it is a bit chaotic.\nSymptoms of complexity:\n change amplification. Seemingly simple change requres change in a lot of different places cognitive load. A developer has to know a lot about the system in order to complete a task unknown unknowns. It is not obvious which part of the code should be modified to complete a task  Complexity is caused by:\n dependencies. When a given piece code can not be understood and modified independently. Often that kind of code is tightly coupled with other modules, in that case you always have to think about coupled modules and modify them as well most likely. obscurity. Important information is not obvious, e.g. it is not clear what method does by its name so you have to scan throug its body to figure that out.  Chapter 3. Working code is not enough Author distinguished two types of mindset — tactical and strategic\nTactical programming means implementing features as quickly as possible. It is almost impossible to produce good design in this case. Perhaps developer is forced to work under a tight deadline and there is simply no room to think about consequences. In this case you do not plan for future you are coming up with a quick and probably dirty solution. In this environment complexity accumulates quickly.\nStrategic programming means that you have to get more time to think about design of a particular solution. It will definitely has its toll in the beginning but will pay off in a long run with clear and simple design that is easy to work.\nThe first step on a path to a become a better programming is to realize — working code is not enough. It is simply no enough to “make things work”. You should double check if any unnecessary complexities has been introduced and eliminate them.\nStrategic programming requires investment mindset. Instead of just shipping features fast you want to take time to improve design of your system. You should strive to do it every time you touch the code.\nChapter 4. Modules should be deep Modular desing allows a programmer to face a portion of design complexity of the system. Author distinguish two types of modules with shallow and deep design. Shallow desing provide lots of method to work with, it gives us “bloated” interface that hide not so much functionality. On the other side well designed deep modules effectively hide complexity and provide a lot of benefit using slim interface. There is a brillian example of file I/O provided by UNIX operating system that gives us 4 simple but yet very powerfull system call to work with.\nChapter 5. Information hiding The basic idea of information hiding is for the module to conceal information that represents design decisions inside. This information is not exposed from the API.\nInformation hiding and deep modules are closely related. If a module hides a lot of information that tends to increase the amount of benefit api provides that makes module really deep.\nFlat/shallow modules with a lot of noise in the api tend to hide little information.\nAlso be aware of temporal decomposition — module split into many classes guided by the order in which operations happen in the runtime or a similar cause. In case of temporal decomposition, classes tend to leak information between each other that makes the whole design cumbersome. That is where deep modules design come into play.\nChapter 6. General purpose modules are deeper. There are two approaches to the module design — general-purpose and special-purpose. General purpose design allows for better system design and deeper module, it is preferrable. General purpose interface reduces cognitive load as well, since developer have to learn just a few simple method to be productive.\nHere is a list of questions that will help to find balance between general-purpose and special-purpose design:\n What is the simplest interface that will cover all my current needs? If you managed to reduce a number of API methods without losing any benefit provided then your module becomes more general-purpose. Note: if you are in a process of simplifying an api but method signature becomes complex with lots of arguments then you are not really simplifying things. In how many situations this method will be used? Is this API is easy to use for my current needs?  Chapter 7. Different layer, different abstraction Software systems consist of layers. Each layer has its own purpose and is able to change data flowing through it. Think OSI model for instance.\nIt is a red flag if a system has a fewer adjacent layers on the same level.\nPass-through methods are methods that do nothing or almost nothing and passing arguments down to the next level. There are ways to solve it with:\n merging both layers into one making the interface of a new layer deeper splitting layer and re-distibuting functionality just call methods of underlying layer directly  Pass-throught variables is another red flag tend to unnecessarily “extend” all underlying layer APIs. Those kind of variables add complexity as well forcing every layer to be aware of their existence but not using it much.\nOne of the ways to fight it is to analyse if there is an object/struct that is already passed through layers. It might make sense to include pass-through variable into this object.\nAnother approach is to store that variable in a global variable accessible everywhere or may be inside environment variable accessible to the entire process/container.\nChapter 8. Pull complexity downwards If you are developing a new module and there is an unavoidable complexity it is better to strive to provide simple interface for this module. Module is always has more users then developers, users of your module should not deal with all the complexity you have.\nChapter 9. Better together or better apart? This chapter discusses the following question — if you have two pieces of functionality how you should deal with them? Should you merge them, should you split them, should you combine them in some clever way?\nIn order to answer this question you have to always remember your ultimate goal — hide complexity, make module/method more deep, increase modularity, strive to simplicity.\n Bring together if information is shared Bring together if it will simplify the interface Bring together to eliminate duplication Separate general-purpose and special purpose code  Chapter 10. Define errors out of existence Error/exception handling is one of the worst sources of complexity. Exceptions/error might happen due numerous reasons and usually programmer tries to throw all kinds of different exceptions. Most of the times exceptions are handled poorly and code that tends to handle exceptions is bloated trying to consider all possible exception cases.\nOne of the ways to combat exceptions and errors is to get rid of the them at all. Consider this example — you are using menthod “Delete” to remove a node from linked list. In case node is not present in the list you might be tempted to throw Exception telling about it to the user. Instead return a successful result as if it was deleted.\nAnother technique is called exception masking and it means you should not throw exception but try to correct the situation. Like in TCP protocol when packet gets lost, protocol does not report an error but instead lost packet is requested again.\nThird way to solve it by exception aggregation, in this case you have one place to catch and handle exceptions instead of doing it all over your code base.\nAnother interesting way is to just crash an application. Some types of errors render any handling next to useless so it makes sense in case of an error to pring debug info and just cransh an application.\nChapter 11. Design it twice For each major design decision you want to consider few different options, you should “measure” and design twice.\nTry to get different appoaches attacking problem at hand from different angles. It will\nChapter 12. Why write comments the four excuses This chapter explains all excuses there are to not write a comments. The core idea of the comments in the system is to express information that is in the mind of the writer and could not be reflected in the code. So comments are highly important.\nChapter 13. Comments should describe things that are not obvious from the code One of the best benefits of comments is abstractions — it includes a lot of not obvious information. Comment should provide a simple, high-level overview of the code. It should be possible to understand what method does by reading a comment and method name.\nPick convetion for commenting and stick to it. Convention will ensure consistency and readability of your comments.\nIn order to write a good comment, you may/should:\n use different words in the comment from those in the method signature/entity/etc.. augment the code by providing a different level of detail. Sometimes you need to provide comment at much lower level than the code is. Such comments add precision. On the other hand there are comments that provide a high-level overview of what is going on, those comments provide intuition. Intuition helps you to understand what, how and why was implemented in a particular way.  Code should be obvious to the reader. Part of an information about the system, implementation is represented in the code, but not all the information can be received by reading code. Comments fill that gap and tell readed the whole story of the system or implementation.\nImportant note — code should be obvious to the reader during code review.\nChapter 14. Choosing names Naming is hard but important, good name decreases complexity, remove any misunderstanding and ambiguities.\nChapter 15. Write the comment first This short chapter boils down to neccessity to write comments first since it is an excellent design tool. It may be sub-optimal to start writing code. Write comments first and use them to shape your understandng of what is going to be implemented.\nChapter 16. Modifying existing code While you are modifying existing code you should apply strategic instead of tactical approach. When you are doing any change you should strive to impove/polish design decisions you are having at hand. If you are not doing it, you are probably making it worse.\nChapter 17. Consistency Consistency is another simple concept that helps you to decrease complexity. What should be consisten in the system:\n naming coding style interfaces with multiple implementation helps to understand system better well know and wisely applied design patterns. You should think twice before applying any pattern  In order to ensure consistency you might write a documentation page about it which is easy to find, also you should definitely add some tools to your pipeline that enforce consistency.\nChapter 18. Code should be obvious Obvious code means you do not have to spend a lot of time to read it in order to understand it. Best way to detect non-obvious code is through code review since to you your code is almost always obvious.\nConsistency, good naming, properly formatted comments make your code more obvious.\nIf code is not obvious then a reader of your code does not have important information about your code. Thus reader might get a wrong assumption about code and do incorrect implementation or spend too much time on implementation.\nChapter 19. Software trends In my opinion this chapter boils down to the wise and old saying — “Question everything”.\nMy favourite part is about Design Patterns. I do respect pattern and I think you should at least know why do we need them and how to implement them. And the greates risk with pattern is over-application, when a programmer starts to apply pattern in such places where a patter does not fit or does not fill well. It is like a hammer for which everything is a nail.\nThat over-application is also true for almost everything else. I’ve seen “clean architecture” applied to the simple CRUD application which made it over-engeneered right of the bat. It is like you finally understood some fucking DDD or whatnot and now you have to apply it at all cost to prove something to yourself or others.\nChapter 20. Designing for performance Main conclusion of this chapter is that clean design and high performance are compatible. Simplicity leads to more performant code.\nIf you have to increase performance of you programm do not rely on your intuition and rush to make changes here and ther. First step is to measure you program’s performance/behaviour and identify bottlenecks you have. Second step is to an actual improvement aroung bottleneck. Author writes that the only way to optimize “critical path” is to do a fundamental change, for example introduce caching, or start to use more efficient data structure that helps you to decrease time/space complexity of an algorithm.\n","wordCount":"2415","inLanguage":"en","datePublished":"2020-09-05T00:00:00Z","dateModified":"2020-09-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://slash3b.github.io/posts/2020-09-05-a-philosophy-of-software-design/"},"publisher":{"@type":"Organization","name":"Random notes to myself","logo":{"@type":"ImageObject","url":"https://slash3b.github.io/favicon.ico"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://slash3b.github.io accesskey=h title="Random notes to myself (Alt + H)">Random notes to myself</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>A philosophy of software design by John Ousterhout</h1><div class=post-meta>September 5, 2020</div></header><div class=post-content><p>I like that book and decided to make a &ldquo;short&rdquo; version for myself to remember it better.<br>The book is only 190 pages long but it has lots of valuable advices and author takes things straight to the point.</p><p>This is just my own &ldquo;retelling&rdquo; of the book. If you are reading this I encourage you to first buy and read the whole
book and only then this text below <strong>might</strong> make sense to you. Or not.</p><h4 id=chapter-1-introduction>Chapter 1. Introduction<a hidden class=anchor aria-hidden=true href=#chapter-1-introduction>#</a></h4><p>&mldr;All programming requires is a creative mind and the ability to organize your thoughts. If you can visualize a system,
you can probably implement it in a computer program. Any system inevitably becomes complex over time — as it grows and
more and more people work on it. Complexity growth makes it next to impossible to hold a clear and complete picture of
a system in one&rsquo;s head.<br>Bottom line is — complexity will grow anyway but it is your reponsibility and duty to hold that growth as much as you
can.</p><p>There are two ways to fight complexity:</p><ul><li>make code more simple and obvious</li><li>incapsulation of a complexity using <em>modular design</em></li></ul><p>Sofware design is never done, it happens through the lifetime of a software. You should always think about system desing
and ways to improve it.</p><h4 id=chapter-2-the-nature-of-complexity>Chapter 2. The nature of complexity<a hidden class=anchor aria-hidden=true href=#chapter-2-the-nature-of-complexity>#</a></h4><p>Complexity is anything related to the structure of a software system that makes it hard to understand, modify and
maintain the system. Another view at complexity is a cost of development — it takes much time to implement event the
simple features, usually you have to change lots of files to do it and overall it is a bit chaotic.</p><p>Symptoms of complexity:</p><ul><li>change amplification. Seemingly simple change requres change in a lot of different places</li><li>cognitive load. A developer has to know a lot about the system in order to complete a task</li><li>unknown unknowns. It is not obvious which part of the code should be modified to complete a task</li></ul><p>Complexity is caused by:</p><ul><li>dependencies. When a given piece code can not be understood and modified independently. Often that kind of code is
tightly coupled with other modules, in that case you always have to think about coupled modules and modify them as
well most likely.</li><li>obscurity. Important information is not obvious, e.g. it is not clear what method does by its name so you have to scan
throug its body to figure that out.</li></ul><h4 id=chapter-3-working-code-is-not-enough>Chapter 3. Working code is not enough<a hidden class=anchor aria-hidden=true href=#chapter-3-working-code-is-not-enough>#</a></h4><p>Author distinguished two types of mindset — tactical and strategic</p><p>Tactical programming means implementing features as quickly as possible. It is almost impossible to produce good design
in this case. Perhaps developer is forced to work under a tight deadline and there is simply no room to think about
consequences. In this case you do not plan for future you are coming up with a quick and probably dirty solution. In
this environment complexity accumulates quickly.</p><p>Strategic programming means that you have to get more time to think about design of a particular solution. It will
definitely has its toll in the beginning but will pay off in a long run with clear and simple design that is easy to work.</p><p>The first step on a path to a become a better programming is to realize — working code is not enough. It is simply no
enough to &ldquo;make things work&rdquo;. You should double check if any unnecessary complexities has been introduced and eliminate
them.</p><p>Strategic programming requires investment mindset. Instead of just shipping features fast you want to take time to
improve design of your system. You should strive to do it every time you touch the code.</p><h4 id=chapter-4-modules-should-be-deep>Chapter 4. Modules should be deep<a hidden class=anchor aria-hidden=true href=#chapter-4-modules-should-be-deep>#</a></h4><p>Modular desing allows a programmer to face a portion of design complexity of the system. Author distinguish two types of
modules with shallow and deep design. Shallow desing provide lots of method to work with, it gives us &ldquo;bloated&rdquo;
interface that hide not so much functionality. On the other side well designed deep modules effectively hide complexity
and provide a lot of benefit using slim interface.
There is a brillian example of file I/O provided by UNIX operating system that gives us 4 simple but yet very powerfull
system call to work with.</p><h4 id=chapter-5-information-hiding>Chapter 5. Information hiding<a hidden class=anchor aria-hidden=true href=#chapter-5-information-hiding>#</a></h4><p>The basic idea of information hiding is for the module to conceal information that represents design decisions inside.
This information is not exposed from the API.</p><p>Information hiding and deep modules are closely related. If a module hides a lot of information that tends to increase the
amount of benefit api provides that makes module really deep.</p><p>Flat/shallow modules with a lot of noise in the api tend to hide little information.</p><p>Also be aware of temporal decomposition — module split into many classes guided by the order in which operations happen
in the runtime or a similar cause. In case of temporal decomposition, classes tend to leak information between each
other that makes the whole design cumbersome. That is where deep modules design come into play.</p><h4 id=chapter-6-general-purpose-modules-are-deeper>Chapter 6. General purpose modules are deeper.<a hidden class=anchor aria-hidden=true href=#chapter-6-general-purpose-modules-are-deeper>#</a></h4><p>There are two approaches to the module design — general-purpose and special-purpose. General purpose design allows for
better system design and deeper module, it is preferrable. General purpose interface reduces cognitive load as well,
since developer have to learn just a few simple method to be productive.</p><p>Here is a list of questions that will help to find balance between general-purpose and special-purpose design:</p><ul><li>What is the simplest interface that will cover all my current needs? If you managed to reduce a number of API methods
without losing any benefit provided then your module becomes more general-purpose. Note: if you are in a process of
simplifying an api but method signature becomes complex with lots of arguments then you are not really simplifying
things.</li><li>In how many situations this method will be used?</li><li>Is this API is easy to use for my current needs?</li></ul><h4 id=chapter-7-different-layer-different-abstraction>Chapter 7. Different layer, different abstraction<a hidden class=anchor aria-hidden=true href=#chapter-7-different-layer-different-abstraction>#</a></h4><p>Software systems consist of layers. Each layer has its own purpose and is able to change data flowing through it. Think
OSI model for instance.<br>It is a red flag if a system has a fewer adjacent layers on the same level.</p><p>Pass-through methods are methods that do nothing or almost nothing and passing arguments down to the next level.
There are ways to solve it with:</p><ul><li>merging both layers into one making the interface of a new layer deeper</li><li>splitting layer and re-distibuting functionality</li><li>just call methods of underlying layer directly</li></ul><p>Pass-throught variables is another red flag tend to unnecessarily &ldquo;extend&rdquo; all underlying layer APIs. Those kind of
variables add complexity as well forcing every layer to be aware of their existence but not using it much.<br>One of the ways to fight it is to analyse if there is an object/struct that is already passed through layers. It might
make sense to include pass-through variable into this object.</p><p>Another approach is to store that variable in a global variable accessible everywhere or may be inside environment
variable accessible to the entire process/container.</p><h4 id=chapter-8-pull-complexity-downwards>Chapter 8. Pull complexity downwards<a hidden class=anchor aria-hidden=true href=#chapter-8-pull-complexity-downwards>#</a></h4><p>If you are developing a new module and there is an unavoidable complexity it is better to strive to provide simple
interface for this module. Module is always has more users then developers, users of your module should not deal with
all the complexity you have.</p><h4 id=chapter-9-better-together-or-better-apart>Chapter 9. Better together or better apart?<a hidden class=anchor aria-hidden=true href=#chapter-9-better-together-or-better-apart>#</a></h4><p>This chapter discusses the following question — if you have two pieces of functionality how you should deal with them?
Should you merge them, should you split them, should you combine them in some clever way?</p><p>In order to answer this question you have to always remember your ultimate goal — hide complexity, make module/method
more deep, increase modularity, strive to simplicity.</p><ul><li>Bring together if information is shared</li><li>Bring together if it will simplify the interface</li><li>Bring together to eliminate duplication</li><li>Separate general-purpose and special purpose code</li></ul><h4 id=chapter-10-define-errors-out-of-existence>Chapter 10. Define errors out of existence<a hidden class=anchor aria-hidden=true href=#chapter-10-define-errors-out-of-existence>#</a></h4><p>Error/exception handling is one of the worst sources of complexity. Exceptions/error might happen due numerous reasons
and usually programmer tries to throw all kinds of different exceptions. Most of the times exceptions are handled
poorly and code that tends to handle exceptions is bloated trying to consider all possible exception cases.</p><p>One of the ways to combat exceptions and errors is to get rid of the them at all. Consider this example — you are using
menthod &ldquo;Delete&rdquo; to remove a node from linked list. In case node is not present in the list you might be tempted to
throw Exception telling about it to the user. Instead return a successful result as if it was deleted.</p><p>Another technique is called exception masking and it means you should not throw exception but try to correct the
situation. Like in TCP protocol when packet gets lost, protocol does not report an error but instead lost packet is
requested again.</p><p>Third way to solve it by exception aggregation, in this case you have one place to catch and handle exceptions instead
of doing it all over your code base.</p><p>Another interesting way is to just crash an application. Some types of errors render any handling next to useless so it
makes sense in case of an error to pring debug info and just cransh an application.</p><h4 id=chapter-11-design-it-twice>Chapter 11. Design it twice<a hidden class=anchor aria-hidden=true href=#chapter-11-design-it-twice>#</a></h4><p>For each major design decision you want to consider few different options, you should &ldquo;measure&rdquo; and design twice.<br>Try to get different appoaches attacking problem at hand from different angles. It will</p><h4 id=chapter-12-why-write-comments-the-four-excuses>Chapter 12. Why write comments the four excuses<a hidden class=anchor aria-hidden=true href=#chapter-12-why-write-comments-the-four-excuses>#</a></h4><p>This chapter explains all excuses there are to not write a comments.
The core idea of the comments in the system is to express information that is in the mind of the writer and could not be
reflected in the code. So comments are highly important.</p><h4 id=chapter-13-comments-should-describe-things-that-are-not-obvious-from-the-code>Chapter 13. Comments should describe things that are not obvious from the code<a hidden class=anchor aria-hidden=true href=#chapter-13-comments-should-describe-things-that-are-not-obvious-from-the-code>#</a></h4><p>One of the best benefits of comments is abstractions — it includes a lot of not obvious information. Comment should
provide a simple, high-level overview of the code. It should be possible to understand what method does by reading a
comment and method name.</p><p>Pick convetion for commenting and stick to it. Convention will ensure consistency and readability of your comments.</p><p>In order to write a good comment, you may/should:</p><ul><li>use different words in the comment from those in the method signature/entity/etc..</li><li>augment the code by providing a different level of detail. Sometimes you need to provide comment at much lower level
than the code is. Such comments add <em>precision</em>. On the other hand there are comments that provide a high-level
overview of what is going on, those comments provide <em>intuition</em>. Intuition helps you to understand what, how and why
was implemented in a particular way.</li></ul><p>Code should be obvious to the reader. Part of an information about the system, implementation is represented in the
code, but not all the information can be received by reading code. Comments fill that gap and tell readed the whole
story of the system or implementation.</p><p>Important note — code should be obvious to the reader during code review.</p><h4 id=chapter-14-choosing-names>Chapter 14. Choosing names<a hidden class=anchor aria-hidden=true href=#chapter-14-choosing-names>#</a></h4><p>Naming is hard but important, good name decreases complexity, remove any misunderstanding and ambiguities.</p><h4 id=chapter-15-write-the-comment-first>Chapter 15. Write the comment first<a hidden class=anchor aria-hidden=true href=#chapter-15-write-the-comment-first>#</a></h4><p>This short chapter boils down to neccessity to write comments first since it is an excellent design tool. It may be
sub-optimal to start writing code. Write comments first and use them to shape your understandng of what is going to be
implemented.</p><h4 id=chapter-16-modifying-existing-code>Chapter 16. Modifying existing code<a hidden class=anchor aria-hidden=true href=#chapter-16-modifying-existing-code>#</a></h4><p>While you are modifying existing code you should apply strategic instead of tactical approach. When you are doing any
change you should strive to impove/polish design decisions you are having at hand. If you are not doing it, you are
probably making it worse.</p><h4 id=chapter-17-consistency>Chapter 17. Consistency<a hidden class=anchor aria-hidden=true href=#chapter-17-consistency>#</a></h4><p>Consistency is another simple concept that helps you to decrease complexity. What should be consisten in the system:</p><ul><li>naming</li><li>coding style</li><li>interfaces with multiple implementation helps to understand system better</li><li>well know and wisely applied design patterns. You should think twice before applying any pattern</li></ul><p>In order to ensure consistency you might write a documentation page about it which is easy to find, also you should
definitely add some tools to your pipeline that enforce consistency.</p><h4 id=chapter-18-code-should-be-obvious>Chapter 18. Code should be obvious<a hidden class=anchor aria-hidden=true href=#chapter-18-code-should-be-obvious>#</a></h4><p>Obvious code means you do not have to spend a lot of time to read it in order to understand it. Best way to detect
non-obvious code is through code review since to you your code is almost always obvious.</p><p>Consistency, good naming, properly formatted comments make your code more obvious.</p><p>If code is not obvious then a reader of your code does not have important information about your code. Thus reader might
get a wrong assumption about code and do incorrect implementation or spend too much time on implementation.</p><h4 id=chapter-19-software-trends>Chapter 19. Software trends<a hidden class=anchor aria-hidden=true href=#chapter-19-software-trends>#</a></h4><p>In my opinion this chapter boils down to the wise and old saying — &ldquo;Question everything&rdquo;.<br>My favourite part is about Design Patterns. I do respect pattern and I think you should at least know why do we need
them and how to implement them. And the greates risk with pattern is over-application, when a programmer starts to apply
pattern in such places where a patter does not fit or does not fill well. It is like a hammer for which everything is a
nail.</p><p>That over-application is also true for almost everything else. I&rsquo;ve seen &ldquo;clean architecture&rdquo; applied to the simple CRUD
application which made it over-engeneered right of the bat. It is like you finally understood some fucking DDD or
whatnot and now you have to apply it at all cost to prove something to yourself or others.</p><h4 id=chapter-20-designing-for-performance>Chapter 20. Designing for performance<a hidden class=anchor aria-hidden=true href=#chapter-20-designing-for-performance>#</a></h4><p>Main conclusion of this chapter is that clean design and high performance are compatible. Simplicity leads to more
performant code.</p><p>If you have to increase performance of you programm do not rely on your intuition and rush to make changes here and
ther. First step is to measure you program&rsquo;s performance/behaviour and identify bottlenecks you have. Second step is to
an actual improvement aroung bottleneck. Author writes that the only way to optimize &ldquo;critical path&rdquo; is to do a
fundamental change, for example introduce caching, or start to use more efficient data structure that helps you to
decrease time/space complexity of an algorithm.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://slash3b.github.io>Random notes to myself</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z" /></svg></a><script>let menu=document.getElementById('menu')
menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>