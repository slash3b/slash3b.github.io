<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Active record vs. Data Mapper | Random notes to myself</title>
<meta name=keywords content><meta name=description content="In Object-oriented programming we often need to persist object to the database for later retrieval. For that to work smart people invented Object-Relation Mapper that does object to db conversion and vise versa. Such ORM object are usually called entities and are passed around in application and are subject to CRUD operations.
ORM implies existence of DBAL(Database Abstraction Layer) and Data Access Layer.

DBAL abstracts Quering language details of different databases and supports many databases at once. Theoretically you can switch seamlessly from one database to another, though I never heard of practical execution of this feature.
Active record and Data Mapper are Data Access Layer patterns or better to say paradigms.

ORM advantages:"><meta name=author content><link rel=canonical href=https://localhost:1313/posts/2019-07-10-active-record-vs-data-mapper/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=https://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=https://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://localhost:1313/posts/2019-07-10-active-record-vs-data-mapper/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Active record vs. Data Mapper"><meta property="og:description" content="In Object-oriented programming we often need to persist object to the database for later retrieval. For that to work smart people invented Object-Relation Mapper that does object to db conversion and vise versa. Such ORM object are usually called entities and are passed around in application and are subject to CRUD operations.
ORM implies existence of DBAL(Database Abstraction Layer) and Data Access Layer.

DBAL abstracts Quering language details of different databases and supports many databases at once. Theoretically you can switch seamlessly from one database to another, though I never heard of practical execution of this feature.
Active record and Data Mapper are Data Access Layer patterns or better to say paradigms.

ORM advantages:"><meta property="og:type" content="article"><meta property="og:url" content="https://localhost:1313/posts/2019-07-10-active-record-vs-data-mapper/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-07-10T00:00:00+00:00"><meta property="article:modified_time" content="2019-07-10T00:00:00+00:00"><meta property="og:site_name" content="Random notes to myself"><meta name=twitter:card content="summary"><meta name=twitter:title content="Active record vs. Data Mapper"><meta name=twitter:description content="In Object-oriented programming we often need to persist object to the database for later retrieval. For that to work smart people invented Object-Relation Mapper that does object to db conversion and vise versa. Such ORM object are usually called entities and are passed around in application and are subject to CRUD operations.
ORM implies existence of DBAL(Database Abstraction Layer) and Data Access Layer.

DBAL abstracts Quering language details of different databases and supports many databases at once. Theoretically you can switch seamlessly from one database to another, though I never heard of practical execution of this feature.
Active record and Data Mapper are Data Access Layer patterns or better to say paradigms.

ORM advantages:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Active record vs. Data Mapper","item":"https://localhost:1313/posts/2019-07-10-active-record-vs-data-mapper/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Active record vs. Data Mapper","name":"Active record vs. Data Mapper","description":"In Object-oriented programming we often need to persist object to the database for later retrieval. For that to work smart people invented Object-Relation Mapper that does object to db conversion and vise versa. Such ORM object are usually called entities and are passed around in application and are subject to CRUD operations.\nORM implies existence of DBAL(Database Abstraction Layer) and Data Access Layer.\nDBAL abstracts Quering language details of different databases and supports many databases at once. Theoretically you can switch seamlessly from one database to another, though I never heard of practical execution of this feature. Active record and Data Mapper are Data Access Layer patterns or better to say paradigms. ORM advantages:\n","keywords":[],"articleBody":"In Object-oriented programming we often need to persist object to the database for later retrieval. For that to work smart people invented Object-Relation Mapper that does object to db conversion and vise versa. Such ORM object are usually called entities and are passed around in application and are subject to CRUD operations.\nORM implies existence of DBAL(Database Abstraction Layer) and Data Access Layer.\nDBAL abstracts Quering language details of different databases and supports many databases at once. Theoretically you can switch seamlessly from one database to another, though I never heard of practical execution of this feature. Active record and Data Mapper are Data Access Layer patterns or better to say paradigms. ORM advantages:\nMost of the time you do not have to write SQL, ORM does that for you behind the scenes Entities are very flexible, you can pass them around, change and when needed persist More clean domain visibility - you have an entity filled with values and comments and annotations and lots of functionality provided by e.g. EntityManager. This lets you abstract away from SQL and operate on domain level ORM disadvantages:\nORM may be suboptimal in efficiency - internal conversion and compilation to SQL takes time, also ORM could do multiple inefficient queries instead of one e.g. N+1 problem It may be very difficult to write complex queries with ORM tooling, actually ORM can not compete with SQL on this field ORMs are also called “leaky abstractions” which means that even though you abstract away from low level details, SQL, you still need to understand what is going on a low level in order to use abstraction efficiently. Active record According to Martin Fowler Active Directory is:\nAn object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data. Object carries both data and behavior.\nMy interpretaion in plain english:\nActive Record implies that an entity represents a table from database and each instance of an entity represents one row from the table, also that entity contains not only data but also all methods/operations to deal with that data. So it typically contains CRUD methods like save(), delete(), update(), find() and etc.\nExamples of AR:\nRuby on Rails Laravel’s Eloquent Propel (Symfony) Yii Active Record Django’s ORM Older version of Doctrine ORM did follow Active Record pattern and an entity was created and saved this way:\n\u003c?php $user = new User(); $user-\u003ename = \"john\"; $user-\u003epassword = \"doe\"; $user-\u003esave(); echo \"The user with id $user-\u003eid has been saved.\"; In Ruby on Rails it could be like this:\nu = User.create(name: \"john\", password: \"doe\") Here is another exaple using Eloquent ORM:\nDefine entity like so:\nclass User extends Model {} and that is basically it. You can fire User::all() in order to get all users.\nThe entity does not have fields mapping becase they are alredy defined in the database.\nSo the major benefits of AR are:\nsimplicity easy to start with Disadvantages are:\nstrong binding between database and application - entities contain domain behaviour apart from the data itself can become messy in big projects Data Mapper From wikipedia:\nA Data Mapper is a Data Access Layer that performs bidirectional transfer of data between a persistent data store (often a relational database) and an in-memory data representation (the domain layer). The goal of the pattern is to keep the in-memory representation and the persistent data store independent of each other and the data mapper itself.\nThat is a long definition and it definitely says something but I need a bit more succint and clear definition, otherwise my brain wont remember it. So I like this by Martin Fowler:\nThe Data Mapper is a layer of software that separates the in-memory objects from the database. Its responsibility is to transfer data between the two and also to isolate them from each other.\nFor instance here an example of Doctine2 Entity:\n\u003c?php // src/Entity/Product.php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; /** * @ORM\\Entity(repositoryClass=\"App\\Repository\\ProductRepository\") */ class Product { /** * @ORM\\Id * @ORM\\GeneratedValue * @ORM\\Column(type=\"integer\") */ private $id; /** * @ORM\\Column(type=\"string\", length=255) */ private $name; /** * @ORM\\Column(type=\"integer\") */ private $price; public function getId() { return $this-\u003eid; } // ... getter and setter methods } Note how it lacks CRUD and domain methods, also mapping definition is done via annotaions.\nExamples of Data Mapper:\nJava Hibernate Doctrine2 SQLAlchemy in Python EntityFramework for Microsoft .NET Golang Prisma Ecto Elixir PHP example with Doctrine2. See, how CRUD et all operations are done with EntityManager and not with Entity itself?\n$user = new User(); $user-\u003esetName(\"john\"); $user-\u003esetPassword(\"doe\"); $entityManager-\u003epersist($user); $entityManager-\u003eflush(); echo \"The user with id \" . $user-\u003egetId() . \"has been saved.\"; Benefits of Data Mapper:\nclear separation of domain logic and database a lot of flexibility. That is arguable of course, because with enough experience AR allows a lot of flexibility too, imo Disadvantages:\nyou have to learn how to work with it may not be easy to set up and start with Brief conclusion: When Active Record tries to make the gap between application and database as thin and seamless as possible, Data Mapper strives to abstract your domain away as much as possible.\nResources used:\nActive record versus Data Mapper\nstackoverfow_1\nDoctrine wiki page in russian\nMartin Fowler Active Record\nMartin Fowler Data Mapper wiki page for DataMapper\nentity example with Symfony and Doctrine\nactive record antipattern ar-vs-data_mapper\n","wordCount":"897","inLanguage":"en","datePublished":"2019-07-10T00:00:00Z","dateModified":"2019-07-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://localhost:1313/posts/2019-07-10-active-record-vs-data-mapper/"},"publisher":{"@type":"Organization","name":"Random notes to myself","logo":{"@type":"ImageObject","url":"https://localhost:1313/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=https://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://localhost:1313/archives/ title=archives><span>archives</span></a></li><li><a href=https://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Active record vs. Data Mapper</h1><div class=post-meta><span title='2019-07-10 00:00:00 +0000 UTC'>July 10, 2019</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;897 words&nbsp;|&nbsp;<a href=https://github.com/slash3b/slash3b.github.io/content/posts/2019-07-10-active-record-vs-data-mapper.markdown rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In Object-oriented programming we often need to persist object to the database for later retrieval. For that to work smart people invented Object-Relation Mapper that does object to db conversion and vise versa. Such ORM object are usually called <em>entities</em> and are passed around in application and are subject to CRUD operations.</p><p>ORM implies existence of DBAL(Database Abstraction Layer) and Data Access Layer.</p><ul><li>DBAL abstracts Quering language details of different databases and supports many databases at once. Theoretically you can switch seamlessly from one database to another, though I never heard of practical execution of this feature.</li><li><em>Active record</em> and <em>Data Mapper</em> are Data Access Layer patterns or better to say paradigms.</li></ul><p>ORM advantages:</p><ul><li>Most of the time you do not have to write SQL, ORM does that for you behind the scenes</li><li>Entities are very flexible, you can pass them around, change and when needed persist</li><li>More clean domain visibility - you have an entity filled with values and comments and annotations and lots of functionality provided by e.g. EntityManager. This lets you abstract away from SQL and operate on domain level</li></ul><p>ORM disadvantages:</p><ul><li>ORM may be suboptimal in efficiency - internal conversion and compilation to SQL takes time, also ORM could do multiple inefficient queries instead of one e.g. N+1 problem</li><li>It may be very difficult to write complex queries with ORM tooling, actually ORM can not compete with SQL on this field</li><li>ORMs are also called &ldquo;leaky abstractions&rdquo; which means that even though you abstract away from low level details, SQL, you still need to understand what is going on a low level in order to use abstraction efficiently.</li></ul><h1 id=active-record>Active record<a hidden class=anchor aria-hidden=true href=#active-record>#</a></h1><p>According to <a href=https://martinfowler.com/eaaCatalog/activeRecord.html>Martin Fowler</a> Active Directory is:</p><blockquote><p>An object that wraps a row in a database table or view, encapsulates the database
access, and adds domain logic on that data. Object carries both data and behavior.</p></blockquote><p>My interpretaion in plain english:</p><blockquote><p>Active Record implies that an entity represents a table from database and each
instance of an entity represents one row from the table, also that entity contains
not only data <strong>but</strong> also all methods/operations to deal with that data. So it
typically contains CRUD methods like <code>save()</code>, <code>delete()</code>, <code>update()</code>, <code>find()</code> and etc.</p></blockquote><p>Examples of AR:</p><ul><li>Ruby on Rails</li><li>Laravel’s Eloquent</li><li>Propel (Symfony)</li><li>Yii Active Record</li><li>Django’s ORM</li></ul><p>Older version of Doctrine ORM did follow Active Record pattern and an entity was created and saved this way:</p><pre tabindex=0><code>&lt;?php
$user = new User();
$user-&gt;name = &#34;john&#34;;
$user-&gt;password = &#34;doe&#34;;
$user-&gt;save();
echo &#34;The user with id $user-&gt;id has been saved.&#34;;
</code></pre><p>In Ruby on Rails it could be like this:</p><pre tabindex=0><code>u = User.create(name: &#34;john&#34;, password: &#34;doe&#34;)
</code></pre><p>Here is another exaple using <a href=https://laravel.com/docs/5.0/eloquent>Eloquent ORM</a>:</p><p>Define entity like so:</p><pre tabindex=0><code>class User extends Model {}
</code></pre><p>and that is basically it. You can fire <code>User::all()</code> in order to get all users.<br>The entity does not have fields mapping becase they <em>are</em> alredy defined in the database.</p><p>So the major benefits of AR are:</p><ul><li>simplicity</li><li>easy to start with</li></ul><p>Disadvantages are:</p><ul><li>strong binding between database and application - entities contain domain behaviour apart from the data itself</li><li>can become messy in big projects</li></ul><h1 id=data-mapper>Data Mapper<a hidden class=anchor aria-hidden=true href=#data-mapper>#</a></h1><p>From wikipedia:</p><blockquote><p>A Data Mapper is a Data Access Layer that performs bidirectional transfer of data between a persistent data store (often a relational database) and an in-memory data representation (the domain layer). The goal of the pattern is to keep the in-memory representation and the persistent data store independent of each other and the data mapper itself.</p></blockquote><p>That is a long definition and it definitely says something but I need a bit more succint and clear definition, otherwise my brain wont remember it. So I like this by Martin Fowler:</p><blockquote><p>The Data Mapper is a layer of software that separates the in-memory objects from the database. Its responsibility is to transfer data between the two and also to isolate them from each other.</p></blockquote><p>For instance here an example of Doctine2 Entity:</p><pre tabindex=0><code>&lt;?php
// src/Entity/Product.php
namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity(repositoryClass=&#34;App\Repository\ProductRepository&#34;)
 */
class Product
{
    /**
     * @ORM\Id
     * @ORM\GeneratedValue
     * @ORM\Column(type=&#34;integer&#34;)
     */
    private $id;

    /**
     * @ORM\Column(type=&#34;string&#34;, length=255)
     */
    private $name;

    /**
     * @ORM\Column(type=&#34;integer&#34;)
     */
    private $price;

    public function getId()
    {
        return $this-&gt;id;
    }

    // ... getter and setter methods
}
</code></pre><p>Note how it lacks CRUD and domain methods, also mapping definition is done via annotaions.</p><p>Examples of Data Mapper:</p><ul><li>Java Hibernate</li><li>Doctrine2</li><li>SQLAlchemy in Python</li><li>EntityFramework for Microsoft .NET</li><li>Golang Prisma</li><li>Ecto Elixir</li></ul><p>PHP example with Doctrine2. See, how CRUD et all operations are done with EntityManager and not with Entity itself?</p><pre tabindex=0><code>
$user = new User();
$user-&gt;setName(&#34;john&#34;);
$user-&gt;setPassword(&#34;doe&#34;);
$entityManager-&gt;persist($user);
$entityManager-&gt;flush();
echo &#34;The user with id &#34; . $user-&gt;getId() . &#34;has been saved.&#34;;
</code></pre><p>Benefits of Data Mapper:</p><ul><li>clear separation of domain logic and database</li><li>a lot of flexibility. That is arguable of course, because with enough experience AR allows a lot of flexibility too, imo</li></ul><p>Disadvantages:</p><ul><li>you have to learn how to work with it</li><li>may not be easy to set up and start with</li></ul><h1 id=brief-conclusion>Brief conclusion:<a hidden class=anchor aria-hidden=true href=#brief-conclusion>#</a></h1><p>When Active Record tries to make the gap between application and database as thin and seamless as possible, Data Mapper strives to abstract your domain away as much as possible.</p><p>Resources used:<br><a href=https://www.thoughtfulcode.com/orm-active-record-vs-data-mapper/>Active record versus Data Mapper</a><br><a href=https://stackoverflow.com/questions/4667906/the-advantages-and-disadvantages-of-using-orm>stackoverfow_1</a><br><a href=https://ru.wikipedia.org/wiki/Doctrine>Doctrine wiki page in russian</a><br><a href=https://martinfowler.com/eaaCatalog/activeRecord.html>Martin Fowler Active Record</a><br><a href=https://martinfowler.com/eaaCatalog/dataMapper.html>Martin Fowler Data Mapper</a><br><a href=https://en.wikipedia.org/wiki/Data_mapper_pattern>wiki page for DataMapper</a><br><a href=https://symfony.com/doc/current/doctrine.html#creating-an-entity-class>entity example with Symfony and Doctrine</a><br><a href=https://www.mehdi-khalili.com/orm-anti-patterns-part-1-active-record>active record antipattern</a>
<a href=https://medium.com/oceanize-geeks/the-active-record-and-data-mappers-of-orm-pattern-eefb8262b7bb>ar-vs-data_mapper</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://localhost:1313/>Random notes to myself</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>